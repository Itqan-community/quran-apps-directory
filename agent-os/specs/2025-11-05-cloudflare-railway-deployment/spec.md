# Specification: Cloudflare Pages + Railway Deployment Infrastructure

## Goal

Deploy the Angular 19 frontend immediately to Cloudflare Pages with automatic GitHub Actions CI/CD, while preparing Railway infrastructure for future Django backend deployment (Phase 2). Enable rapid iteration on the develop branch with zero-downtime deployments and automatic HTTPS.

## User Stories

- As a developer, I want to push code to the develop branch and have it automatically deploy to Cloudflare Pages, so that I can rapidly iterate on frontend features without manual deployment steps
- As a platform engineer, I want Railway infrastructure pre-configured with all required services (Django, PostgreSQL, Redis, Celery), so that backend deployment is streamlined when Django code is ready

## Specific Requirements

### Phase 1 - Frontend Deployment to Cloudflare Pages

**Cloudflare Pages Project Setup**
- Create Cloudflare Pages project named "Quran Apps Directory Frontend"
- Connect to GitHub repository: Itqan-community/quran-apps-directory
- Configure automatic deployment only from develop branch initially (not staging/main)
- Use Cloudflare auto-generated subdomain (e.g., quran-apps-directory.pages.dev) without custom domains
- Framework preset: Angular (Node.js 18.x or 20.x)
- Build command: `npm run build:dev` (outputs to dist/browser/)
- Build output directory: `dist/browser` (Angular 19 standalone output path)
- Root directory: `/` (repository root)
- Install command: `npm install` (default, auto-detected)
- No environment variables needed in Cloudflare Pages dashboard (all config committed in environment.ts files)

**SPA Routing Configuration**
- Create `_redirects` file in Angular build output to handle client-side routing
- Configure catch-all rule: `/* /index.html 200` to serve index.html for all routes
- Ensure no 404 errors on route refresh (e.g., /apps/123 must work on direct navigation)
- Add `_headers` file for security headers (X-Frame-Options, X-Content-Type-Options, CSP)
- Preserve query parameters and hash fragments during redirects

**GitHub Actions Workflow for Frontend**
- Create workflow file: `.github/workflows/deploy-cloudflare-develop.yml`
- Trigger on push to develop branch only (not PRs, not other branches)
- Build Angular application with `npm run build:dev`
- Deploy to Cloudflare Pages using Wrangler CLI or Cloudflare Pages API
- Verify deployment success with health check (HTTP 200 response)
- Total deployment time target: Under 10 minutes from push to live
- Store CLOUDFLARE_API_TOKEN and CLOUDFLARE_ACCOUNT_ID in GitHub Secrets
- Use official Cloudflare GitHub Action: cloudflare/pages-action@v1 or cloudflare/wrangler-action@v3

**HTTPS and Security**
- Rely on Cloudflare Pages automatic HTTPS with auto-renewing certificates
- No custom SSL certificate configuration needed
- Enforce HTTPS redirects (HTTP → HTTPS) automatically via Cloudflare
- Set security headers: Content-Security-Policy, X-Frame-Options: DENY, X-Content-Type-Options: nosniff
- Enable Cloudflare's default DDoS protection and WAF

**Build Optimization**
- Run sitemap generation before build: `node generate-sitemap.js`
- Verify build output directory exists and contains index.html
- Cache node_modules in GitHub Actions for faster builds
- No compression needed (Cloudflare handles Brotli/Gzip automatically)
- Validate Angular build completes successfully before deployment

### Phase 1 - Railway Infrastructure Setup (No Code Deployment Yet)

**Railway Project Creation**
- Create Railway project named "Quran Apps Directory Backend"
- Set up project in Railway dashboard (not CLI initially for better visibility)
- Connect to GitHub repository: Itqan-community/quran-apps-directory
- Configure to watch develop branch (but do not deploy backend code yet)
- Use Railway's private networking for inter-service communication
- Enable Railway's automatic HTTPS with custom domain support (for Phase 2)

**PostgreSQL Database Service**
- Add PostgreSQL service to Railway project (version 15 or 16)
- Database name: `quran_apps_db`
- Enable daily automatic backups (Railway default)
- Configure 1 GB storage initially (expandable in Phase 2)
- Expose DATABASE_URL environment variable (auto-generated by Railway)
- Use private networking URL for Django connection (not public URL)
- Set shared_preload_libraries for pg_stat_statements (performance monitoring)

**Redis Cache Service**
- Add Redis service to Railway project (latest stable version)
- Configure 512 MB memory limit initially (expandable in Phase 2)
- Expose REDIS_URL environment variable (auto-generated by Railway)
- Use as Celery message broker and Django cache backend
- Enable Redis persistence (RDB snapshots) for durability
- Use private networking URL for service-to-service communication

**Django API Service (Placeholder)**
- Add empty service named "Django API" to Railway project
- Connect to backend/ directory in GitHub repository
- Do NOT deploy yet (wait for Django code to be ready in Phase 2)
- Configure start command: `python railway_start.py` (runs migrations + starts Gunicorn)
- Set Python version: 3.11 or 3.12
- Configure environment variables placeholders: SECRET_KEY, DEBUG=False, ALLOWED_HOSTS, CORS_ALLOWED_ORIGINS
- Reference DATABASE_URL and REDIS_URL from other services via private networking
- Set healthcheck endpoint: /api/health/ (to be implemented in Phase 2)

**Celery Worker Service (Placeholder)**
- Add empty service named "Celery Worker" to Railway project
- Connect to backend/ directory in GitHub repository
- Do NOT deploy yet (wait for Django code to be ready in Phase 2)
- Configure start command: `celery -A config worker --loglevel=info`
- Reference REDIS_URL from Redis service
- Share Django codebase with Django API service (same repository, different Procfile entry)
- Set concurrency: 2-4 workers initially

**Celery Beat Service (Placeholder)**
- Add empty service named "Celery Beat" to Railway project
- Connect to backend/ directory in GitHub repository
- Do NOT deploy yet (wait for Django code to be ready in Phase 2)
- Configure start command: `celery -A config beat --loglevel=info`
- Reference REDIS_URL from Redis service
- Use Django database scheduler (django-celery-beat) for task persistence
- Configure timezone: UTC for consistent scheduling

**Service Networking and Dependencies**
- Configure private networking between all 5 services
- Django API depends on: PostgreSQL (DATABASE_URL), Redis (REDIS_URL)
- Celery Worker depends on: Redis (CELERY_BROKER_URL), PostgreSQL (DATABASE_URL), Django API (shared code)
- Celery Beat depends on: Redis, PostgreSQL (for django-celery-beat)
- PostgreSQL and Redis have no dependencies (base services)
- Use Railway's service reference syntax: `${{Postgres.DATABASE_URL}}` in environment variables

### GitHub Secrets Configuration

**Cloudflare Secrets**
- CLOUDFLARE_API_TOKEN: API token with Cloudflare Pages edit permissions (create at dash.cloudflare.com/profile/api-tokens)
- CLOUDFLARE_ACCOUNT_ID: Cloudflare account ID (found in Cloudflare dashboard URL)
- CLOUDFLARE_PROJECT_NAME: "quran-apps-directory" (Pages project name)

**Railway Secrets (Phase 2)**
- RAILWAY_TOKEN: API token for Railway CLI (create at railway.app/account/tokens)
- DJANGO_SECRET_KEY: Django secret key (generate with `python -c 'from django.core.management.utils import get_random_secret_key; print(get_random_secret_key())'`)

**Security Best Practices**
- Never commit secrets to code or GitHub Actions workflow files
- Store all sensitive values in GitHub Secrets (not Cloudflare Pages env vars)
- Rotate tokens every 90 days (set calendar reminders)
- Use least-privilege access (API tokens with minimal required permissions)
- Document all required secrets in project README

### Deployment Workflow

**Git Push to Deploy Pipeline**
- Developer pushes code to develop branch
- GitHub detects push event and triggers workflow: `.github/workflows/deploy-cloudflare-develop.yml`
- Workflow checks out code, installs dependencies, runs `npm run build:dev`
- Workflow deploys build output to Cloudflare Pages via Wrangler or Pages API
- Cloudflare Pages automatically invalidates CDN cache
- Deployment completes in 5-10 minutes total
- Developer receives notification in GitHub Actions UI (success/failure)
- Frontend immediately accessible at auto-generated pages.dev URL

**Rollback Strategy**
- Cloudflare Pages maintains deployment history (last 10 deployments)
- Rollback via Cloudflare dashboard: Select previous deployment → "Rollback to this deployment" (instant)
- Alternative: Revert Git commit and push to trigger new deployment
- No downtime during rollback (Cloudflare handles gracefully)

**Validation Steps**
- Automated health check in GitHub Actions: `curl -f https://quran-apps-directory.pages.dev/`
- Manual verification: Visit pages.dev URL and test critical user flows (app list, app detail, dark mode, language toggle)
- Run Lighthouse audit: `npm run lighthouse` targeting deployed URL
- Check browser console for errors (especially CORS errors when API added in Phase 2)

### Phase 2 Preparation - Backend Deployment Readiness

**Django Migration Strategy**
- Configure Railway start command to run migrations automatically: `python manage.py migrate && gunicorn config.wsgi:application`
- Use Django's migration system with no manual SQL scripts
- Ensure migrations are idempotent (safe to re-run)
- Monitor migration execution in Railway logs
- Set DJANGO_SETTINGS_MODULE=config.settings.production for production settings

**CORS Configuration for Cloudflare Pages**
- Add Cloudflare Pages origin to Django CORS_ALLOWED_ORIGINS setting
- Example: `CORS_ALLOWED_ORIGINS = ['https://quran-apps-directory.pages.dev', 'https://dev.quran-apps.itqan.dev']`
- Enable CORS headers in Django REST Framework: corsheaders middleware
- Allow credentials if using JWT authentication: `CORS_ALLOW_CREDENTIALS = True`
- Test CORS configuration with browser developer tools (check preflight OPTIONS requests)

**Railway Service Health Checks**
- Implement `/api/health/` endpoint in Django returning 200 OK with JSON: `{"status": "healthy", "timestamp": "2025-11-05T12:00:00Z"}`
- Configure Railway health check path: `/api/health/`
- Set health check interval: 30 seconds
- Set failure threshold: 3 consecutive failures before marking unhealthy
- Health check should verify: database connection, Redis connection, application startup

**Backend Deployment Checklist**
- Django 5.2 codebase complete in backend/ directory
- requirements.txt includes all dependencies (Django, djangorestframework, psycopg2-binary, redis, celery, gunicorn, django-cors-headers)
- Procfile defines all process types: web, worker, beat
- railway.toml defines service configurations
- Environment variables configured in Railway dashboard
- Database migrations tested locally with Docker PostgreSQL
- CORS origins include Cloudflare Pages URL
- Static files configured for collectstatic (STATIC_ROOT, STATIC_URL)
- Health check endpoint implemented and tested

### Future Expansion Preparation

**Staging Branch Deployment**
- Duplicate Cloudflare Pages project for staging: "Quran Apps Directory Staging"
- Create GitHub Actions workflow: `.github/workflows/deploy-cloudflare-staging.yml`
- Build command: `npm run build:staging` (includes compression)
- Configure custom domain: staging.quran-apps.itqan.dev (requires DNS changes)
- Deploy Railway backend to separate staging project (isolated database)

**Production Branch Deployment**
- Create Cloudflare Pages project for production: "Quran Apps Directory Production"
- Create GitHub Actions workflow: `.github/workflows/deploy-cloudflare-production.yml`
- Build command: `npm run build:prod` (full optimization)
- Configure custom domain: quran-apps.itqan.dev
- Require manual approval for production deployments (GitHub Environments feature)
- Deploy Railway backend to production project with higher resource allocation

**Pull Request Preview Deployments**
- Enable Cloudflare Pages PR previews in project settings
- Each PR gets unique preview URL: pr-123-quran-apps.pages.dev
- Automatically deploy and comment PR preview URL on GitHub PR
- Preview deployments use same build command as develop branch
- Automatically delete preview deployments when PR is closed

**Custom Domain Configuration**
- Add CNAME records in Cloudflare DNS:
  - dev.quran-apps.itqan.dev → quran-apps-directory.pages.dev
  - staging.quran-apps.itqan.dev → quran-apps-staging.pages.dev
  - quran-apps.itqan.dev → quran-apps-prod.pages.dev
- Configure custom domains in Cloudflare Pages dashboard
- Wait for SSL certificate provisioning (automatic, 5-10 minutes)
- Update Angular environment files with custom domain URLs

**Monitoring and Alerting**
- Enable Cloudflare Web Analytics (free, privacy-friendly)
- Configure Railway deployment notifications (Slack, Discord, email)
- Set up Sentry for error tracking (Phase 2 when backend deployed)
- Configure Uptime Robot for endpoint monitoring (free tier: 5-minute intervals)
- Add Railway usage alerts when approaching plan limits

## Visual Design

No visual assets provided (infrastructure specification).

## Existing Code to Leverage

**Package.json Build Scripts**
- `npm run build:dev` - Development build without optimization (fast builds for iteration)
- `npm run build:staging` - Staging build with compression and moderate optimization
- `npm run build:prod` - Production build with full optimization, minification, sitemap generation
- `npm run generate-sitemap` - Sitemap generation script (runs automatically before builds)
- All scripts already defined and tested locally, ready for CI/CD usage

**Angular Environment Files Pattern**
- `src/environments/environment.ts` - Development config with localhost API URL
- `src/environments/environment.staging.ts` - Staging config with staging.api.quran-apps.itqan.dev
- `src/environments/environment.prod.ts` - Production config with api.quran-apps.itqan.dev
- Angular build system automatically swaps environment files based on build configuration
- Railway API URLs will follow this established pattern (no code changes needed)

**Existing GitHub Actions Workflows**
- `.github/workflows/deploy-development.yml` - Digital Ocean SSH deployment (can be adapted for Railway pattern)
- `.github/workflows/deploy-and-migrate.yml` - Combined deployment and migration workflow
- `.github/workflows/migrate.yml` - Database migration workflow
- Existing workflows demonstrate SSH deployment pattern, secrets management, and verification steps
- Can reuse workflow structure and secret naming conventions

**Backend Configuration Files**
- `backend/Procfile` - Process definitions for Railway (currently has web process)
- `backend/nixpacks.toml` - Build configuration for Railway Nixpacks
- `backend/railway_start.py` - Custom start script for Railway (handles migrations)
- `backend/run_server.py` - Server startup script
- These files exist and can be extended with Celery worker/beat process definitions

**Railway CLI Commands**
- `railway login` - Already authenticated
- `railway link` - Link local directory to Railway project
- `railway up` - Deploy services manually (fallback if GitHub Actions fails)
- `railway logs` - View service logs for debugging
- `railway run` - Run commands in Railway environment (e.g., migrations)

## Out of Scope

### Explicitly Excluded from Initial Implementation

**Infrastructure and Deployment**
- Custom SSL certificates (use Cloudflare/Railway automatic certificates)
- Docker containerization (use Railway Nixpacks auto-detection for Python)
- Kubernetes or container orchestration (Railway abstracts this)
- Multi-region deployment or global load balancing
- Infrastructure as Code tools (Terraform, Pulumi, CDK)
- Blue-green deployments or canary releases
- Serverless functions or edge computing (not needed for this architecture)

**CI/CD and Automation**
- Staging and main branch deployments (add after develop branch working)
- Pull request preview deployments (add after initial deployment stable)
- Automated testing in CI/CD pipeline (no tests exist yet)
- Code quality checks (linting, formatting) in CI/CD
- Security scanning (Snyk, Dependabot) in workflow
- Performance regression testing in CI/CD
- Visual regression testing

**Monitoring and Observability**
- Custom monitoring dashboards (Grafana, Datadog)
- Application Performance Monitoring (APM) beyond platform defaults
- Distributed tracing (Jaeger, Zipkin)
- Log aggregation beyond Railway/Cloudflare defaults
- Error tracking services (Sentry) integration
- Uptime monitoring and alerting (Uptime Robot, Pingdom)
- Cost monitoring and billing alerts

**Database and Data Management**
- Custom database backup strategies (use Railway daily backups)
- Database replication or read replicas
- Database connection pooling (PgBouncer)
- Database migration rollback automation
- Data seeding or fixtures automation
- Database performance tuning beyond indexes

**Security and Compliance**
- Web Application Firewall (WAF) rules (use Cloudflare defaults)
- Rate limiting and DDoS protection beyond platform defaults
- Secrets rotation automation
- Security audit logging
- Compliance certifications (SOC 2, GDPR technical controls)
- Penetration testing or security scanning

**Backend Features (Phase 2)**
- Django backend code deployment (wait until Django code ready)
- Email service integration (SendGrid, AWS SES)
- File upload and storage (AWS S3, Cloudflare R2)
- Celery task scheduling and monitoring
- API rate limiting middleware
- JWT authentication and authorization
- Websockets or real-time features
- GraphQL API (using REST API only)

**Frontend Optimizations**
- Custom CDN cache invalidation rules (Cloudflare handles automatically)
- Service worker custom caching strategies
- Progressive Web App (PWA) advanced features
- Image optimization pipeline beyond Angular defaults
- Bundle size analysis and optimization alerts
- A/B testing infrastructure

**Documentation and Training**
- Video tutorials or screencasts
- Architecture decision records (ADRs) beyond this spec
- Runbooks for incident response
- Team training materials
- API documentation generation (drf-spectacular in Phase 2)

